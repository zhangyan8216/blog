## 问题分析

### 当前架构问题

1. **双登录系统**：前端React和后端Flask各自有独立的登录页面

   * 前端：`/login` -> `/admin`（React组件）

   * 后端：`/login` -> `/admin/dashboard`（模板渲染）

2. **登录重定向混乱**：

   * URL中出现 `?next=http://localhost:5000/admin/`

   * 不同入口登录导致页面不一致

3. **架构混乱**：

   * 前端和后端都有各自的登录认证逻辑

   * 代码重复，维护困难

   * 用户体验差

### 目标架构

参考Memory-Core项目，采用清晰的分层架构：

* **后端**：Flask REST API + JWT认证

* **前端**：React SPA + 统一用户状态管理

* **统一登录**：单点登录，所有入口使用相同认证流程

## 重构计划

### 1. 后端重构

**统一认证系统**：

* 使用JWT（JSON Web Token）进行用户认证

* 创建统一登录API：`POST /api/auth/login`

* 创建登出API：`POST /api/auth/logout`

* 创建用户信息API：`GET /api/auth/me`

* 添加Token验证中间件

**移除重复代码**：

* 移除后端模板渲染的登录页面

* 移除Blueprint中的旧登录路由

* 只保留REST API接口

### 2. 前端重构

**统一用户状态管理**：

* 使用Context API管理用户认证状态

* 创建AuthContext，包含：

  * user状态

  * login函数

  * logout函数

  * isAuthenticated检查

**简化路由结构**：

* `/` - 首页（公开）

* `/login` - 登录页（公开）

* `/register` - 注册页（公开）

* `/admin` - 后台管理（需要登录）

**移除重复页面**：

* 移除后端模板相关的登录页面

* 统一使用前端登录页面

### 3. 技术实现细节

**后端JWT认证**：

```python
# 安装依赖
pip install PyJWT

# 创建JWT工具函数
import jwt
from datetime import datetime, timedelta

SECRET_KEY = 'your-secret-key'  # 生产环境应使用环境变量

def create_token(user_id, username):
    payload = {
        'user_id': user_id,
        'username': username,
        'exp': datetime.utcnow() + timedelta(days=7)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')

def verify_token(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        return None
```

**前端AuthContext**：

```typescript
// 创建AuthContext
interface AuthContextType {
  user: User | null;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
}

// 在App.tsx中使用
<AuthProvider>
  <AppRoutes />
</AuthProvider>
```

### 4. 实施步骤

1. **准备阶段**：

   * 安装PyJWT依赖

   * 创建JWT工具模块

   * 修改requirements.txt

2. **后端实施**：

   * 修改`blueprints/auth.py`，添加JWT认证

   * 创建统一登录API

   * 移除模板渲染的登录路由

3. **前端实施**：

   * 创建`contexts/AuthContext.tsx`

   * 修改`Navbar.tsx`，使用AuthContext

   * 修改`Login.tsx`，调用后端API

   * 修改`App.tsx`，添加路由守卫

4. **清理阶段**：

   * 移除后端模板文件（login.html等）

   * 移除未使用的Blueprint路由

   * 清理代码中的重复逻辑

### 5. 预期效果

* ✅ 统一的登录页面和流程

* ✅ JWT Token认证，安全性更高

* ✅ 登录后页面一致

* ✅ 清晰的代码架构，易于维护

* ✅ 支持前后端分离部署

