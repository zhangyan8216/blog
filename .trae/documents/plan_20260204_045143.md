## 问题分析

**现象**：在博客后台新建的博客在主页不显示

**原因**：API返回错误 `TypeError: '<' not supported between instances of 'datetime.datetime' and 'datetime.date'`

**具体分析**：
1. 在 `get_posts()` 函数中，当对文章按日期排序时出现类型错误
2. 日期类型不一致的原因：
   - 新创建的文章（通过API）：`date` 字段是ISO格式的字符串
   - 旧文章（通过文件读取）：如果没有日期元数据，`date` 字段是 `datetime.datetime` 对象
   - 当 `yaml.safe_load()` 解析日期字符串时，可能会返回 `datetime.date` 对象

## 解决方案

### 修复 `get_posts()` 函数
1. **统一日期类型**：确保所有文章的 `date` 字段都是相同类型，最好是 `datetime.datetime` 对象
2. **处理不同类型的日期**：
   - 如果是字符串，解析为 `datetime.datetime` 对象
   - 如果是 `datetime.date` 对象，转换为 `datetime.datetime` 对象
   - 如果是 `datetime.datetime` 对象，保持不变

### 修复步骤

1. **修改 `app.py` 中的 `get_posts()` 函数**：
   - 在添加文章到 `posts` 列表之前，统一处理 `date` 字段的类型
   - 确保所有日期都是 `datetime.datetime` 对象

2. **测试修复效果**：
   - 重启Flask服务
   - 访问API端点 `/api/posts`，确保返回所有文章
   - 访问主页，确保新创建的文章显示出来

## 技术细节

在 `get_posts()` 函数中，需要添加日期类型统一处理逻辑：

```python
# 统一日期类型
if isinstance(metadata.get('date'), str):
    # 解析ISO格式的日期字符串
    try:
        metadata['date'] = datetime.fromisoformat(metadata['date'])
    except ValueError:
        metadata['date'] = datetime.now()
elif isinstance(metadata.get('date'), date) and not isinstance(metadata.get('date'), datetime):
    # 将date对象转换为datetime对象
    metadata['date'] = datetime.combine(metadata['date'], datetime.min.time())
```

这样可以确保所有文章的 `date` 字段都是 `datetime.datetime` 对象，排序时就不会出错了。